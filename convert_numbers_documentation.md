
# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```
# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```

# usage 
## convert number to all possible bases 
```python
# input the number with its base
print( p(243, 10) )
```
## convert number to only one desired base
```python
# to_b -> 'to binary'
# to_m -> 'to marsian/base 4'
# to_o -> 'to octal'
# to_h -> 'to hexadecimal'
print( p(243, 10).to_b() )
```
## convert number to only one custom base
```python
print( p(243, 10).to_base(13) )
```

## calculating/operating with numbers

you can operate with two instances

```python
print( p(243, 10) + p(10010, 2) )

print( p(243, 10) - p(10010, 2) )

print( p(243, 10) * p(10010, 2) )

print( p(243, 10) / p(10010, 2) )

```

since a new p(...) instance is returned you can apply more functions after wrapping the return in round brackets (p(...) + p(...)).to_h()
```python

print( ( p(243, 10) + p(10010, 2) ).to_base(13)

```

# multiple conversion array/list/batch 
you can convert multiple numbers , by using the p like this
```
print( p(2, 4, 8, 16, 32, 128, 243, 10).to_b() )
```
